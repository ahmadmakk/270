#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>
#include <string.h>

#define GRID_SIZE 10


typedef struct {
    char hide[10][10]; 
    char display[10][10]; 
    bool smoked[10][10];// add smoked to the phase1 code
} Grid; 

typedef struct {
    char *name;
    int cells;
    int hitCount;
    bool isSunk;// add it to phase1
} Ship;

typedef struct Player {
    bool smoked[GRID_SIZE][GRID_SIZE];
    char *name;
    Grid own;
    Ship ships[4];
    int radarUses;
    int smokeUses;
    int countSunk;
    bool Torpedo;
    bool Artillery;
    bool isBot; // add to code phase1 to Determines if the player is a bot
    bool isTurn; // Tracks whose turn it is
} Player;

//add grid display code from firts phase here

// initializes a player (human or bot)'s grid
void initializePlayer(Player *player, const char *name, bool isBot) {
    player->name= name;
    player->radarUses = 3;
    player->smokeUses = 0;
    player->countSunk = 0;
    player->Torpedo = false;
    player->Artillery = false;
    player->isBot = isBot;
    player->isTurn = false;



    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            player->own.display[i][j] = '~';
            player->own.hide[i][j] = '~';
            player->own.smoked[i][j] = false;// since countsunk 
        }
    }

//to assign ships
    Ship shipss[] = {{"carrier", 5, 0, false}, {"battleship", 4, 0, false}, {"destroyer", 3, 0, false}, {"submarine", 2, 0, false}};
    for (int i = 0; i < 4; i++) {
        player->ships[i] = shipss[i];
    }
}

// bot makes a strategic moveby taking turn, fire move is included
void takeTurn(Player *attacker, Player *defender, int difficulty) {
    // Display updated opponent (defender) grid before the turn
    printf("Updated grid for %s:\n", defender->name);
    printGrid(defender->own.display);

    if (attacker->isBot) {
        // bot logic
        int probabilityGrid[GRID_SIZE][GRID_SIZE] = {0};
        calculateProbability(probabilityGrid, defender);

        // prioritizing special moves, flip torpedo and artilery since torpedo is stronger
        if (attacker->Artillery) {
            botArtilleryAttack(attacker, defender, probabilityGrid);
            attacker->Artillery = false;
            return;
        } else if (attacker->Torpedo) {
            botTorpedoStrike(attacker, defender);
            attacker->Torpedo = false;
            return;
        } else if (attacker->radarUses > 0) {
            botRadar(attacker, defender);
            attacker->radarUses--;
            return;
        } else if (attacker->smokeUses > 0) {
            botSmoke(attacker);
            attacker->smokeUses--;
            return;
        }

        // fire move based on probability
        int targetRow, targetCol;
        selectTarget(&targetRow, &targetCol, probabilityGrid);

        if (validateCoordinates(targetRow, targetCol)) {
            applyHit(attacker, defender, targetRow, targetCol);
        }
    } else {
        // human logic
        int move;
        printf("%s, choose your move Fire(1)/Radar(2)/Smoke(3)/Artillery(4)/Torpedo(5): ", attacker->name);
        scanf("%d", &move);

        switch (move) {
            case 1:
                fire(attacker, defender);
                break;
            case 2:
                printf("Radar sweep selected!\n");
                Radar(attacker, defender, false);  
                break;
            case 3:
                printf("Smoke Screen selected!\n");
                Smoke(attacker, false);  
                break;
            case 4:
                printf("Artillery Attack selected!\n");
                artilleryAttack(attacker, defender, false, NULL); 
                break;
            case 5:
                printf("Torpedo selected!\n");
                torpedoStrike(attacker, defender, false, NULL);  
                break;
            default:
                printf("Invalid move!\n");
        }
    }

    // to display updated opponent (defender) grid after the turn
    printf("Updated grid for %s:\n", defender->name);
    printGrid(defender->own.display);

    // for human turn, prompt to pass the device
    if (!attacker->isBot) {
        printf("Your turn is over, press any key and pass the device to %s\n", defender->name);
        char str[2];
        scanf("%s", &str);
        system("cls");
    }
}



// calculate probability grid
void calculateProbability(int probabilityGrid[GRID_SIZE][GRID_SIZE], Player *human) {
    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            if (human->own.display[i][j] == '~') { 
                for (int k = 0; k < 4; k++) {
                    Ship *ship = &human->ships[k];
                    if (!ship->isSunk) {
                        // check horizontal placement
                        if (j + ship->cells <= GRID_SIZE) {
                            probabilityGrid[i][j]++;
                        }
                        // vertical placement
                        if (i + ship->cells <= GRID_SIZE) {
                            probabilityGrid[i][j]++;
                        }
                    }
                }
            }
        }
    }
}

// selecting the highestprobability target
void selectTarget(int *targetRow, int *targetCol, int probabilityGrid[GRID_SIZE][GRID_SIZE]) {
    int maxProbability = -1;

    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            if (probabilityGrid[i][j] > maxProbability) {
                maxProbability = probabilityGrid[i][j];
                *targetRow = i;
                *targetCol = j;
            }
        }
    }
}

// Artillery attack, same as phase1, adjusted for both humans, and human witha  bot
void artilleryAttack(Player *attacker, Player *opponent, bool isBotTurn, int probabilityGrid[GRID_SIZE][GRID_SIZE]) {
    if (!attacker->Artillery) {
        printf("%s's Artillery move not unlocked!\n", isBotTurn ? "Bot" : attacker->name);
        return;
    }

    int sunkshipprev = attacker->countSunk;
    int topLeftCol, topLeftRow;

    if (isBotTurn) {
        // bot : select target based on probability
        selectTarget(&topLeftRow, &topLeftCol, probabilityGrid);
        printf("Bot uses Artillery at %c%d!\n", 'A' + topLeftCol, topLeftRow + 1);
    } else {
        // human: get input from the user for coordinates
        char coord[4];
        printf("%s, enter coordinates for artillery strike (top-left of 2x2 area): ", attacker->name);
        scanf("%s", coord);

       
        topLeftCol = letterToNumber(coord[0]);
        if (coord[1] == '1' && coord[2] == '0') {
            topLeftRow = 9;  
        } else if (coord[1] == '1' && coord[2] != 0) {
            topLeftRow = 20;  
        } else {
            topLeftRow = coord[1] - '1'; 
        }
    }

   
    if (!validateCoordinates(topLeftRow, topLeftCol) || !validateCoordinates(topLeftRow + 1, topLeftCol + 1)) {
        printf("%s selected an invalid artillery target area. Turn skipped.\n", isBotTurn ? "Bot" : attacker->name);
        return;
    }

    bool hit = false;

   
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            int row = topLeftRow + i;
            int col = topLeftCol + j;
            char cellInHide = opponent->own.hide[row][col];
            char cellInDisplay = opponent->own.display[row][col];

            if (cellInHide != '~') {  // it's a ship
                opponent->own.display[row][col] = '*';
                hit = true;  

               
                for (int k = 0; k < 4; k++) {
                    if (cellInHide == opponent->ships[k].name[0]) {
                        opponent->ships[k].hitCount++;

                       
                        if (isShipSunk(&opponent->ships[k])) {
                            printf("%s sunk a %s!\n", attacker->name, opponent->ships[k].name);
                            attacker->countSunk++;

                           
                            attacker->Artillery = true;
                            attacker->smokeUses++;

                            if (attacker->countSunk == 3) {
                                attacker->Torpedo = true;
                            }
                        }
                        break;
                    }
                }
            } else {  // Water cell
                if (difficulty == 1) {  
                    opponent->own.display[row][col] = 'o';  
                }
            }
        }
    }

    
    if (hit) {
        printf("Hit!\n");
    } else {
        printf("Miss!\n");
    }

    
    if (sunkshipprev == attacker->countSunk) {
        attacker->Artillery = false;
        attacker->Torpedo = false;
    }

    
    printf("%s's grid after the artillery strike:\n", opponent->name);
    printGrid(opponent->own.display);  
}



// TorpedoStrike, I adjusted the phase1 code again to adapt to when we have a bot playing
//need to cahnge opponent from Player to Bot
void torpedoStrike(Player *attacker, Player *opponent, bool isBotTurn, int probabilityGrid[GRID_SIZE][GRID_SIZE]) {
    if (!attacker->Torpedo) {
        printf("%s's Torpedo move not unlocked!\n", isBotTurn ? "Bot" : attacker->name);
        return;
    }

    int line = -1;  // row or column index
    bool isRow = true;  // true for row attack, false for column attack

    if (isBotTurn) {
        // probability to decide row or column
        int rowProb[GRID_SIZE] = {0}, colProb[GRID_SIZE] = {0};

        // calculates probabilities for rows and columns
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (opponent->own.display[i][j] == '~') {
                    rowProb[i]++;
                    colProb[j]++;
                }
            }
        }

        
        int maxIndex = 0, maxValue = -1;
        for (int i = 0; i < GRID_SIZE; i++) {
            if (rowProb[i] > maxValue) {
                maxValue = rowProb[i];
                maxIndex = i;
                isRow = true;
            }
            if (colProb[i] > maxValue) {
                maxValue = colProb[i];
                maxIndex = i;
                isRow = false;
            }
        }

        line = maxIndex;  //chooses the largest line
        printf("Bot uses Torpedo on %s %d!\n", isRow ? "row" : "column", line + 1);
    } else {
       
        int choice;
        printf("%s, choose Row(1) or Column(2) for Torpedo: ", attacker->name);
        scanf("%d", &choice);

        if (choice == 1) {
            isRow = true;
            printf("Choose a row from 1 to 10: ");
            scanf("%d", &line);
            line--;  
        } else {
            isRow = false;
            char c;
            printf("Choose a column from A to J: ");
            scanf(" %c", &c);
            line = letterToNumber(c);  
        }
    }

    bool hit = false;

    if (isRow) {
        
        for (int j = 0; j < GRID_SIZE; j++) {
            char cell = opponent->own.hide[line][j];
            if (cell != '~' && cell != '*') {
                hit = true;
                opponent->own.display[line][j] = '*';
                opponent->own.hide[line][j] = '*';

                
                for (int i = 0; i < 4; i++) {
                    if (cell == opponent->ships[i].name[0]) {
                        opponent->ships[i].hitCount++;
                        if (isShipSunk(&opponent->ships[i])) {
                            printf("%s sunk a %s!\n", attacker->name, opponent->ships[i].name);
                            attacker->countSunk++;

                            
                            attacker->Artillery = true;
                            attacker->smokeUses++;
                            if (attacker->countSunk == 3) {
                                attacker->Torpedo = true;
                            }
                        }
                        break;
                    }
                }
            } else if (cell == '~') {
                opponent->own.display[line][j] = 'O'; 
            }
        }
    } else {
       
        for (int i = 0; i < GRID_SIZE; i++) {
            char cell = opponent->own.hide[i][line];
            if (cell != '~' && cell != '*') {
                hit = true;
                opponent->own.display[i][line] = '*';
                opponent->own.hide[i][line] = '*';

               
                for (int k = 0; k < 4; k++) {
                    if (cell == opponent->ships[k].name[0]) {
                        opponent->ships[k].hitCount++;
                        if (isShipSunk(&opponent->ships[k])) {
                            printf("%s sunk a %s!\n", attacker->name, opponent->ships[k].name);
                            attacker->countSunk++;

                          
                            attacker->Artillery = true;
                            attacker->smokeUses++;
                            if (attacker->countSunk == 3) {
                                attacker->Torpedo = true;
                            }
                        }
                        break;
                    }
                }
            } else if (cell == '~') {
                opponent->own.display[i][line] = 'O';  
            }
        }
    }

    
    if (hit) {
        printf("Torpedo hit!\n");
    } else {
        attacker->Artillery = false;  
        printf("Torpedo miss.\n");
    }

    attacker->Torpedo = false;  
}


// Radar, adapted for the bot
void Radar(Player *attacker, Player *opponent, bool isBotTurn) {
   
    if (isBotTurn) {
        attacker->Torpedo = false;
        attacker->Artillery = false;
    } else {
        attacker->Torpedo = false;
        attacker->Artillery = false;
    }

    
    if ((isBotTurn && attacker->radarUses <= 0) || (!isBotTurn && attacker->radarUses <= 0)) {
        printf("%s has no radar scans left. Turn skipped.\n", isBotTurn ? "Bot" : attacker->name);
        return;
    }

    int topLeftRow = -1, topLeftCol = -1;

    if (isBotTurn) {
       
        for (int i = 0; i < GRID_SIZE - 1; i++) {
            for (int j = 0; j < GRID_SIZE - 1; j++) {
                if (opponent->own.display[i][j] == '~' &&
                    opponent->own.display[i + 1][j] == '~' &&
                    opponent->own.display[i][j + 1] == '~' &&
                    opponent->own.display[i + 1][j + 1] == '~') {
                    topLeftRow = i;
                    topLeftCol = j;
                    printf("Bot uses Radar at %c%d!\n", 'A' + j, i + 1);
                    break;
                }
            }
            if (topLeftRow != -1) break;//stop scanning once a valid area is found
        }
    } else {
        
        char coord[4];
        printf("%s, enter coordinates for radar scan (top-left of 2x2 area): ", attacker->name);
        scanf("%s", coord);

    \
        topLeftCol = letterToNumber(coord[0]);
        if (coord[1] == '1' && coord[2] == '0') {
            topLeftRow = 9; 
        } else if (coord[1] == '1' && coord[2] != 0) {
            topLeftRow = 20; 
        } else {
            topLeftRow = coord[1] - '1'; 
        }
    }

    
    if (!validateCoordinates(topLeftRow, topLeftCol) ||
        !validateCoordinates(topLeftRow + 1, topLeftCol + 1)) {
        printf("%s selected an invalid radar scan area. Turn skipped.\n", isBotTurn ? "Bot" : attacker->name);
        return;
    }

 
    bool shipsFound = false;
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            if (opponent->smoked[topLeftRow + i][topLeftCol + j]) { 
                continue;
            }

            char currentCell = opponent->own.hide[topLeftRow + i][topLeftCol + j];
            if (currentCell == 'c' || currentCell == 'b' || currentCell == 'd' || currentCell == 's') {
                shipsFound = true;
                break; 
            }
        }
        if (shipsFound) break;
    }

  
    if (shipsFound) {
        printf("%s's radar detected enemy ships in the area!\n", isBotTurn ? "Bot" : attacker->name);
    } else {
        printf("%s's radar detected no enemy ships in the area.\n", isBotTurn ? "Bot" : attacker->name);
    }


    attacker->radarUses--;
}





void Smoke(Player *human, Bot *bot, bool isBotTurn) {
   
    if (isBotTurn) {
        bot->Artillery = false;
        bot->Torpedo = false;
    } else {
        human->Artillery = false;
        human->Torpedo = false;
    }

    
    if ((isBotTurn && bot->smokeUses <= 0) || (!isBotTurn && human->smokeUses <= 0)) {
        printf("%s has no smoke screens left. Turn skipped.\n", isBotTurn ? "Bot" : human->name);
        return;
    }

    int topLeftRow = -1, topLeftCol = -1;

    if (isBotTurn) {
       
        for (int i = 0; i < GRID_SIZE - 1; i++) {
            for (int j = 0; j < GRID_SIZE - 1; j++) {
                if (bot->own.hide[i][j] != '~') { 
                    topLeftRow = i;
                    topLeftCol = j;
                    printf("Bot places Smoke at %c%d!\n", 'A' + j, i + 1);
                    break;
                }
            }
            if (topLeftRow != -1) break; 
        }
    } else {
        
        char coord[4];
        printf("%s, enter coordinates for smoke screen (top-left of 2x2 area): ", human->name);
        scanf("%s", coord);

       
        topLeftCol = letterToNumber(coord[0]);
        if (coord[1] == '1' && coord[2] == '0') {
            topLeftRow = 9; 
        } else if (coord[1] == '1' && coord[2] != 0) {
            topLeftRow = 20;
        } else {
            topLeftRow = coord[1] - '1'; 
        }
    }

    
    if (!validateCoordinates(topLeftRow, topLeftCol) ||
        !validateCoordinates(topLeftRow + 1, topLeftCol + 1)) {
        printf("%s selected an invalid smoke area. Turn skipped.\n", isBotTurn ? "Bot" : human->name);
        return;
    }

    
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            if (isBotTurn) {
                bot->own.smoked[topLeftRow + i][topLeftCol + j] = true;
            } else {
                human->own.smoked[topLeftRow + i][topLeftCol + j] = true;
            }
        }
    }

    
    if (isBotTurn) {
        bot->smokeUses--;
    } else {
        human->smokeUses--;
    }

    
    system("cls");

    printf("%s placed a smoke screen successfully!\n", isBotTurn ? "Bot" : human->name);
}


//hardlevel fct 
void hardLevel(Player *human, Player *bot) {
    
    initializePlayer(human, "Human", false);
    initializePlayer(bot, "Bot", true);

    
    while (true) {
        
        if (human->isTurn) {
            
            takeTurn(human, bot, 2);  

           
            if (isGameOver(bot)) {
                displayWinner(human); 
                break;
            }
        } else {
            
            int probabilityGrid[GRID_SIZE][GRID_SIZE] = {0};
            calculateProbability(probabilityGrid, human); 
            if (bot->Artillery) {
                int targetRow, targetCol;
                selectTarget(&targetRow, &targetCol, probabilityGrid); 
                botArtilleryAttack(bot, human, probabilityGrid);     
                Move_Coord(bot->name, "Artillery", targetRow, targetCol, false, false); 
                bot->Artillery = false;  
            } else if (bot->Torpedo) {
                int isRow = 0, target = 0;
                decideTorpedoTarget(probabilityGrid, &isRow, &target);  
                if (isRow) {
                    botTorpedoStrikeRow(bot, human, target);          
                    Move_Coord(bot->name, "Torpedo", target, -1, true, true); 
                } else {
                    botTorpedoStrikeColumn(bot, human, target);      
                    Move_Coord(bot->name, "Torpedo", -1, target, false, true); 
                }
                bot->Torpedo = false;  
            } else if (bot->radarUses > 0) {
                int targetRow, targetCol;
                selectTarget(&targetRow, &targetCol, probabilityGrid);  
                botRadar(bot, human);                                  
                Move_Coord(bot->name, "Radar", targetRow, targetCol, false, false); 
                bot->radarUses--;  
            } else if (bot->smokeUses > 0) {
                botSmoke(bot); 
                Move_Coord(bot->name, "Smoke", -1, -1, false, false);
                bot->smokeUses--;  
            } else {
               
                int targetRow, targetCol;
                selectTarget(&targetRow, &targetCol, probabilityGrid); 
                if (validateCoordinates(targetRow, targetCol)) {
                    applyHit(bot, human, targetRow, targetCol);        
                    Move_Coord(bot->name, "Fire", targetRow, targetCol, false, false); 
                }
            }

           
            if (isGameOver(human)) {
                displayWinner(bot);  
                break;
            }
        }

        
        switchTurns(human, bot);
    }
}




// fct to hit somewhere
void applyHit(Player *attacker, Player *defender, int row, int col) {
    char *cell = &defender->own.hide[row][col];
    char *displayCell = &defender->own.display[row][col];

    if (*cell != '~' && *cell != '*') { 
        *cell = '*'; 
        *displayCell = '*'; 
        printf("%s hits at %c%d!\n", attacker->name, 'A' + col, row + 1);

        
        for (int i = 0; i < 4; i++) {
            if (defender->ships[i].name[0] == *cell) {
                defender->ships[i].hitCount++;
                if (defender->ships[i].hitCount == defender->ships[i].cells) {
                    defender->ships[i].isSunk = true; 
                    printf("%s sunk your %s!\n", attacker->name, defender->ships[i].name);
                }
                break; 
            }
        }
    } else {//miss
        *displayCell = 'O'; 
        printf("%s misses at %c%d.\n", attacker->name, 'A' + col, row + 1);
    }
}


// move coordinates fct to display the coordinates of each move made by the bot or human
void Move_Coord(const char *playerName, const char *moveType, int row, int col, bool isRow, bool isTorpedo) {
    printf("%s used %s at ", playerName, moveType);

    if (isTorpedo) {
        if (isRow) {
            printf("Row %d\n", row + 1); //torpedo row
        } else {
            printf("Column %c\n", 'A' + col); // torpedo column
        }
    } else {
        printf("Coordinates %c%d\n", 'A' + col, row + 1); 
    }
}
//bot placing coordinates startegically, more around edges, to make it hard to human to guess(it has lowest prob)
void botPlaceShips(Player *bot) {
    for (int i = 0; i < 4; i++) {
        Ship *ship = &bot->ships[i];
        bool placed = false;

        while (!placed) {
            int orientation = rand() % 2; // 0 for horizontal  1 for vertical
            int startRow, startCol;

            if (orientation == 0) { // horizontal placement
                startRow = (rand() % 2 == 0) ? 0 : GRID_SIZE - 1; 
                startCol = rand() % (GRID_SIZE - ship->cells + 1); 
            } else { // vertical placement
                startRow = rand() % (GRID_SIZE - ship->cells + 1); 
                startCol = (rand() % 2 == 0) ? 0 : GRID_SIZE - 1; 
            }

          
            if (validateShipPlacement(bot->own.hide, startRow, startCol, ship->cells, orientation)) {
                // placing ship directly in the grid
                for (int j = 0; j < ship->cells; j++) {
                    int row = startRow + (orientation == 1 ? j : 0); // increment row for vertical
                    int col = startCol + (orientation == 0 ? j : 0); // inc col for horizontal
                    bot->own.hide[row][col] = ship->name[0]; 
                }
                placed = true; 
            }
        }
    }
}



//validating the placement of ships
bool validateShipPlacement(char grid[GRID_SIZE][GRID_SIZE], int startRow, int startCol, int shipSize, int orientation) {
    for (int i = 0; i < shipSize; i++) {
        int row = startRow + (orientation == 1 ? i : 0); // increment row for vertical placement
        int col = startCol + (orientation == 0 ? i : 0); // incrementing column for horizontal placement

        // checking for  bounds and ensure the cell is empty
        if (!validateCoordinates(row, col) || grid[row][col] != '~') {
            return false; 
        }
    }
    return true; 
}




// the main function
int main() {
    Player player1, player2;

    printf("Select Difficulty Level: 1-Easy, 2-Medium, 3-Hard: ");
    int difficulty;
    scanf("%d", &difficulty);

    if (difficulty == 1) {
        easyLevel(&player1, &player2); 
    } else if (difficulty == 2) {
        mediumLevel(&player1, &player2);  
    } else if (difficulty == 3) {
        hardLevel(&player1, &player2);  
    } else {
        printf("Invalid difficulty selection!\n");
    }

    return 0;
}
//what coordinates used when each speciat move is taken 
//retun the move with coordinates
